# Найти цену игры и оптимальные смешанные стратегии обоих игроков при помощи
# итеративного метода Брауна - Робисон
import numpy as np


c = np.array([[0, -1.065, -1.38], [-0.93, -1.095, -0.51], [-3.36, -2.625, -1.14]])  # матрица игры
print(1/(np.array([1, 1, 1]) @ np.linalg.inv(c) @ np.array([1, 1, 1]).reshape(-1, 1))) # аналитическое нахождение цены игры
x = np.zeros(3, dtype=int) # хранение выбранных стратегий
y = np.zeros(3, dtype=int)
strat_A, strat_B = 0, 0 # стратегии первого раунда
k = 1  # номер раунда
x[strat_A] += 1  # Добавляем выбранную стратегию A
y[strat_B] += 1  # Добавляем выбранную стратегию B
sumA = c[0:, strat_B]  # возможные выигрыши A при стратегии выбранной B
sumB = c[strat_A, 0:]  # возможные проигрыши B при стратегии выбранной A
v1 = np.array([np.max(sumA)])  # массив верхних переделов цены игры
v2 = np.array([np.min(sumB)])  # массив нижних пределов цены игры
eps = np.min(v1)-np.max(v2)  # погрешность
print("| K | A| B| X1 | X2 | X3 | Y1 | Y2 | Y3 |  V1  |  V2  | Eps  |")
print("|%3d|x%d|y%d|%4d|%4d|%4d|%4d|%4d|%4d|%6.3f|%6.3f|%6.3f|" \
      % (k, strat_A+1, strat_B+1, sumA[0], sumA[1], sumA[2], sumB[0], sumB[1], sumB[2], v1[k-1], v2[k-1], eps))
while eps > 0.1:
    k += 1
    strat_A = np.argmax(sumA)  # A выбирает наиболее выгодную стратегию
    strat_B = np.argmin(sumB)  # B выбирает наиболее выгодную стратегию
    x[strat_A] += 1  # Добавляем выбранную стратегию A
    y[strat_B] += 1  # Добавляем выбранную стратегию B
    sumA = sumA + c[0:, strat_B]  # изменяем возможные выигрыши A учитываю стратегию выбранную B
    sumB = sumB + c[strat_A, 0:]  # изменяем возможные проигрыши B учитываю стратегию выбранную A
    v1 = np.append(v1, np.max(sumA)/k)  # добавление нового значения верхнего предела цены игры
    v2 = np.append(v2, np.min(sumB)/k)  # добавление нового значения нижнего предела цены игры
    eps = np.min(v1) - np.max(v2)  # рассчет погрешности
    print("|%3d|x%d|y%d|%4d|%4d|%4d|%4d|%4d|%4d|%6.3f|%6.3f|%6.3f|" \
          % (k, strat_A+1, strat_B+1, sumA[0], sumA[1], sumA[2], sumB[0], sumB[1], sumB[2], v1[k-1], v2[k-1], eps))
print("Выбранные стратегии %s %s" % (x, y))
